{"meta":{"title":"JasonWe","subtitle":"Keep going,never stop","description":"Code & Life","author":"Jason We","url":"https://jason-we.github.io","root":"/"},"pages":[{"title":"about","date":"2020-10-17T06:34:37.000Z","updated":"2020-10-19T09:17:03.531Z","comments":true,"path":"about/index.html","permalink":"https://jason-we.github.io/about/index.html","excerpt":"","text":""},{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2020-10-19T09:17:03.531Z","comments":true,"path":"404.html","permalink":"https://jason-we.github.io/404.html","excerpt":"","text":""},{"title":"contact","date":"2020-10-17T06:35:09.000Z","updated":"2020-10-19T09:17:03.532Z","comments":true,"path":"contact/index.html","permalink":"https://jason-we.github.io/contact/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-17T06:32:43.000Z","updated":"2020-10-19T09:17:03.532Z","comments":true,"path":"categories/index.html","permalink":"https://jason-we.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-10-17T06:35:55.000Z","updated":"2020-10-19T09:17:03.533Z","comments":true,"path":"friends/index.html","permalink":"https://jason-we.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-17T06:33:34.000Z","updated":"2020-10-19T09:17:03.533Z","comments":true,"path":"tags/index.html","permalink":"https://jason-we.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"并发问题思考1","slug":"并发问题思考1","date":"2020-12-10T08:31:23.000Z","updated":"2021-01-05T02:31:16.073Z","comments":true,"path":"2020/12/10/bing-fa-wen-ti-si-kao-1/","link":"","permalink":"https://jason-we.github.io/2020/12/10/bing-fa-wen-ti-si-kao-1/","excerpt":"","text":"最近开发项目以及学习过程中对于并发问题的解决方式没有清晰的思路。遂学习之，先做个记录吧。 并发问题并发遇到的常见问题就是，多个客户端同时操作同一个资源，会出现一些意想不到的异常情况。这里的‘操作’如果都是查询，那问题还不大，如果这些操作包含了修改、新增、删除等会涉及到服务端数据库改动的，那么就会产生问题。 并发的一般解决思路就是做控制。具体说，就是要在并发操作发生的环节里去做一些干预性的事儿，来让抢这个资源的请求们都消停一下，最终通过一定的干预让每个请求都能获得正常的响应，同时让这个被请求资源也舒舒服服的，避免发生不必要的意外zzz. 干预手段1首先想到的是用数据库的锁策略，以mysql为例，InnoDB支持行级锁，在操作可能产生并发问题的资源时，可使用简单的语句控制，如可以开启事务start transaction，使用for update给资源加锁；具体的做法要结合使用的语言及框架查阅mysql官方文档，或百度之。for update作用于不同的表字段时加锁效果不同，对主键而言是行级锁，对普通字段则是表级锁，具体使用时还是要先做测试验证其加锁粒度。 干预手段2网上看了一圈，发现有些文章说可以使用redis做并发控制，在这里按我的理解描述一下： 在后端使用redis作缓存，把每一个客户端过来的请求都缓存起来，并设置缓存过期时间，这样一来，由于redis的唯一性以及单线程原子性，同样的请求每次只能有一个被缓存，这个被缓存的请求就是幸运儿，可以对这个资源进行操作了。其他的请求则都被redis拦在了门外。 这个思路想一想其实就相当于让redis 当看大门的呗0.o 。在可能有并发问题出现的地方安置一个redis看门大爷，每次请求过来先去问redis大爷让不让进去（执行实际业务操作）；也还相当于把redis当成一把锁，去锁相应的资源。 这个解决方案也存在一些局限或是问题： 复杂性： 服务端处理请求时变复杂了一些（问题不大） 唯一性判断问题： 根据请求判断唯一性，可能需要对请求做一些限制，或是截取请求的一部分。 这种解决方案会有局限，即无法解决不同请求产生的并发问题（只对不同用户同时进行同样的请求有效） 缓存过期时间问题：设置多久合适？ 还是不设置，在完成请求后手动释放（删除redis表对应记录） 重试机制问题：被拒之门外的请求作何处理？ 目前想的就是简单的返回给客户端一个提示 （eg：请稍等，过几秒再来吧？） 干预手段2.1有了上面的思路，结合最近做的项目，又有了一个具体些的想法，就是用redis去锁数据库对应表的主键字段并自己设计加锁策略。对于操作mysql数据库来说，即将mysql表的唯一性字段（通常为主键）使用redis进行缓存，每当有请求过来时，首先去redis查询对应的主键字段有没有被锁住，（具体可使用redis的hset ？），若没有被锁则可以操作此资源，否则直接返回。（相当于行级锁） 存在的问题： 可靠性：若redis缓存挂掉，则不能控制并发。 死锁： 若两个及以上的请求同时操作多个行的资源可能会产生死锁问题。 系统开销： 使用redis无疑增加了系统开销。 局限性：只适合简单的并发修改等操作 总结本文主要概括性的讲了并发问题的几个解决方案，即使用数据库层面的并发能力，使用redis进行并发控制的一些思路，具体的操作还需要动手实践，实践出真知。 并发问题是开发中很常见也是一直以来都很棘手的问题，在学习并发理论知识的同时，更需要多实践并在实践中积累经验，才能有针对性的解决不同场景下的并发问题。","categories":[],"tags":[{"name":"并发","slug":"并发","permalink":"https://jason-we.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"思考","slug":"思考","permalink":"https://jason-we.github.io/tags/%E6%80%9D%E8%80%83/"}]},{"title":"nginx使用总结","slug":"nginx使用总结","date":"2020-10-31T09:30:42.000Z","updated":"2020-11-12T09:03:48.496Z","comments":true,"path":"2020/10/31/nginx-shi-yong-zong-jie/","link":"","permalink":"https://jason-we.github.io/2020/10/31/nginx-shi-yong-zong-jie/","excerpt":"","text":"使用nginx作代理服务器在做前后端项目分离并部署到生产环境上时，可以选择nginx作前端项目的服务器，使用起来还是很方便的。同时，仅需简单的配置即可实现端接口转发，具体操作可以看之前的一篇blog: vue cli3.0+ 跨域配置 nginx常用命令--nginx 启停命令 start nginx.exe //启动nginx nginx.exe -s stop //停止nginx nginx.exe -s quit //优雅停止nginx，有连接时会等连接请求完成再杀死worker进程 nginx.exe -s reload //重启，会重新加载nginx的配置文件 （*linux相应命令去掉 \".exe\" 后缀即可） --nginx 其他命令 nginx -v 查看版本 nginx -t 检查nginx的配置文件 nginx -h 查看帮助信息 nginx -V 详细版本信息，包括编译参数 nginx -c filename 指定配置文件 -- Linux 下nginx常用运维命令 ps -ef |grep nginx 查看nginx的进程号 whereis nginx 查看nginx安装路径 配置nginx开机自启动 $ sudo systemctl start nginx #systemd OR $ sudo service nginx start #sysvinit","categories":[{"name":"服务器","slug":"服务器","permalink":"https://jason-we.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://jason-we.github.io/tags/nginx/"},{"name":"服务器","slug":"服务器","permalink":"https://jason-we.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"vue cli3.0+ 跨域配置","slug":"vue-cli3-0-跨域配置","date":"2020-10-28T13:29:47.000Z","updated":"2020-11-12T09:03:48.496Z","comments":true,"path":"2020/10/28/vue-cli3-0-kua-yu-pei-zhi/","link":"","permalink":"https://jason-we.github.io/2020/10/28/vue-cli3-0-kua-yu-pei-zhi/","excerpt":"","text":"配置baseURL根据项目axios的引入方式， 可以分为两种配置方式： 如果axios 是npm install 加入的，那可以在在项目的main.js中配置： Axios.defaults.baseURL = '/api' 如果是通过vue@cli ，即 vue add axios 加入的，则可以在plugins文件夹中的axios.js中配置： let config = { baseURL: '/api' // baseURL: process.env.baseURL || process.env.apiUrl || \"\" // timeout: 60 * 1000, // Timeout // withCredentials: true, // Check cross-site Access-Control }; 配置axios跨域配置完baseURL后，就可以根据baseURL进行跨域配置了。 开发环境 新建vue.config.js，并在其中配置跨域方案： module.exports = { devServer: { //这里解决开发环境的跨域问题， 生产环境的跨域问题需要再nginx服务器解决 proxy: { '/api': { // 此处的写法，目的是为了 将 /api 替换成 http://localhost:8088/ target: 'http://localhost:8088/', // 允许跨域 changeOrigin: true, ws: true, pathRewrite: { '^/api': '' } } } } } 生产环境 使用nginx 服务器， 配置文件nginx.conf 中增加server的配置 ： listen 8081; server_name localhost; location / { root html; #这里的html是指 nginx根目录的html文件夹，即你项目打包好的dist目录下的文件全部拷贝至这里，（要先将html目录下的文件删掉） index index.html index.htm; try_files $uri $uri/ /index.html; } location /api/ { #这里/api/的配置和上面的baseURL的配置是对应的。 proxy_pass http://localhost:8088/; #这里的配置表示将请求都转发至这个地址 } ok，以上就是使用vue cli 3.0+ 开发vue项目时配置axios跨域的常见解决办法啦。留作备忘！","categories":[{"name":"vue","slug":"vue","permalink":"https://jason-we.github.io/categories/vue/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://jason-we.github.io/tags/nginx/"},{"name":"vue","slug":"vue","permalink":"https://jason-we.github.io/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://jason-we.github.io/tags/axios/"}]},{"title":"懒人自述","slug":"懒人自述","date":"2020-10-20T00:54:06.000Z","updated":"2020-10-20T01:47:37.707Z","comments":true,"path":"2020/10/20/lan-ren-zi-shu/","link":"","permalink":"https://jason-we.github.io/2020/10/20/lan-ren-zi-shu/","excerpt":"","text":"关于我一个真实的懒人，一向懒得写文章，做笔记，回顾大学的时光，图书馆没少泡，书没少看，习也没少学；奈何本人很笨，不能做到过目不忘，所以一直都是”狗熊掰棒子“，学多少忘多少，直到现在回首，惊觉大学四年没留下像样点的个人记录，不甚惋惜。所以，近来顿悟，想做一点记录，给自己留点痕迹，也是对逝去的时光一个交代吧。至于为什么选hexo，没别的，从众就完了 😷 关于博客初衷最初的想法如上所言，做记录，所以就当是一个人记录本吧😹。而且本人虽说是科班出身，但是全身上下无不透露出一个”菜“字，所以，纯技术型博客俺也没辣个能力，自己本身就是天天面向CSDN、github编程的划水型选手，还是老老实实做记录吧。当然，工作的关系，可能还是少不了技术方面的内容，如果您一不小心看到了某篇拙作，还请您务必抱有怀疑批判的眼光，多多留言指正，鄙人先在这里拜谢了（抱拳）。 目的 做记录，给自己留点痕迹，给时间一个交代。 锻炼文档撰写能力，养成一个写文档做记录的好习惯 通过做记录，让自己获得一种充实感 如果文章有幸帮助到了别人，还能收获一份帮助他人的快乐☺ 对自己的一点期望万事开头难，希望这个开头我能坚持下来，度过难关，养成写文章的好习惯。也敦促自己去不断地学习，不要安于现状，走出舒适区。加油​，​奥力给💪💪","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://jason-we.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://jason-we.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"个人记录","slug":"个人记录","permalink":"https://jason-we.github.io/tags/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"}]},{"title":"Hexo博客搭建之使用git分支实现多终端环境","slug":"Hexo博客搭建之使用git分支实现多终端环境","date":"2020-10-19T09:21:55.000Z","updated":"2020-10-20T00:34:46.581Z","comments":true,"path":"2020/10/19/hexo-bo-ke-da-jian-zhi-shi-yong-git-fen-zhi-shi-xian-duo-zhong-duan-huan-jing/","link":"","permalink":"https://jason-we.github.io/2020/10/19/hexo-bo-ke-da-jian-zhi-shi-yong-git-fen-zhi-shi-xian-duo-zhong-duan-huan-jing/","excerpt":"","text":"问题 该文前提默认你已经使用hexo在GitHub上搭建起了自己的博客系统，强烈建议先搭建好博客再读此文！ 如果你现在在自己的笔记本上写的博客，部署在了网站上，那么你在家里用台式机，或者实验室的台式机，发现你电脑里面没有博客的文件，或者要换电脑了，最后不知道怎么移动文件，怎么办？ 在这里我们就可以利用git的分支系统进行多终端工作了，这样每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，就可以无缝操作了。 hexo机制由于hexo d上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。 也就是上传的是在本地目录里自动生成的.deploy_git里面。 其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github 所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。 具体操作新建分支首先在你的github pages项目仓库（如我的是Jason-We.github.io新建一个分支，名称自拟，可以是hexo。 然后在这个仓库的settings中，选择默认分支为hexo（这样每次同步的时候就不用指定分支，比较方便）。 本地克隆在本地的任意你喜欢的目录下，将上述仓库克隆下来，因为默认分支已经设成了hexo，所以clone时只clone了hexo。接下来在克隆到本地的ZJUFangzh.github.io中，把除了.git 文件夹外的所有文件都删掉 把之前我们写的博客源文件全部复制过来，除了.deploy_git。这里应该说一句，复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git： .DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ 注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。 然后， git add . git commit –m \"add branch\" git push 这样就上传完了，可以去你的github上看一看hexo分支有没有上传上去，其中node_modules、public、db.json已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。 换电脑操作在你已经安装好了git、nodejs、hexo的机器上，再任意你喜欢的空文件夹下，将你上述push好的的仓库克隆到本机。进入到该目录后，执行： npm install npm install hexo-deployer-git --save 之后 ， 生成+部署： hexo g hexo d 至此，已经搞定啦。接下来就可以在这台机器上愉快的写博客了。 hexo new \"你的文章名称\" Tips 不要忘了，每次写完最好都把源文件上传一下 git add . git commit –m \"xxxx\" git push 123 如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了 git pull","categories":[{"name":"hexo","slug":"hexo","permalink":"https://jason-we.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://jason-we.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://jason-we.github.io/tags/git/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://jason-we.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"第一篇博客","slug":"第一篇博客","date":"2020-10-16T02:52:23.000Z","updated":"2020-10-16T07:48:12.648Z","comments":true,"path":"2020/10/16/di-yi-pian-bo-ke/","link":"","permalink":"https://jason-we.github.io/2020/10/16/di-yi-pian-bo-ke/","excerpt":"","text":"First Blog使用Typora进行博客文章编写。 Readable &amp; WritableTypora gives you a seamless experience as both a reader and a writer. It removes the preview window, mode switcher, syntax symbols of markdown source code, and all other unnecessary distractions. Instead, it provides a real live preview feature to help you concentrate on the content itself.","categories":[],"tags":[{"name":"first","slug":"first","permalink":"https://jason-we.github.io/tags/first/"}]}],"categories":[{"name":"服务器","slug":"服务器","permalink":"https://jason-we.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"vue","slug":"vue","permalink":"https://jason-we.github.io/categories/vue/"},{"name":"碎碎念","slug":"碎碎念","permalink":"https://jason-we.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"hexo","slug":"hexo","permalink":"https://jason-we.github.io/categories/hexo/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://jason-we.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"思考","slug":"思考","permalink":"https://jason-we.github.io/tags/%E6%80%9D%E8%80%83/"},{"name":"nginx","slug":"nginx","permalink":"https://jason-we.github.io/tags/nginx/"},{"name":"服务器","slug":"服务器","permalink":"https://jason-we.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"vue","slug":"vue","permalink":"https://jason-we.github.io/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://jason-we.github.io/tags/axios/"},{"name":"博客","slug":"博客","permalink":"https://jason-we.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"个人记录","slug":"个人记录","permalink":"https://jason-we.github.io/tags/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"},{"name":"hexo","slug":"hexo","permalink":"https://jason-we.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://jason-we.github.io/tags/git/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://jason-we.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"first","slug":"first","permalink":"https://jason-we.github.io/tags/first/"}]}